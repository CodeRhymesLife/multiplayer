<!doctype html>
<html>
<head>
  <link href="index.css" rel=stylesheet>
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700&display=swap" rel="stylesheet">
  <script src="https://kit.fontawesome.com/0735724151.js" crossorigin="anonymous"></script>
  <!-- <script src="https://www.gstatic.com/firebasejs/7.9.2/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/7.9.2/firebase-database.js"></script> -->
  <script src="https://rawcdn.githack.com/ethereum/web3.js/a6ddec59e65116853435f203b25cb9c55824d084/dist/web3.min.js"></script>
  <script src="https://rawcdn.githack.com/ethereumjs/browser-builds/c31acaf66608f8176828b974ab50f2ea6308e7e1/dist/ethereumjs-tx/ethereumjs-tx-1.3.3.js"></script>
  <script src="https://rawcdn.githack.com/ConsenSys/eth-lightwallet/d21df74dd2d5e09632bf38309f147784668b1498/dist/lightwallet.js"></script>
</head>
<body>
  <header id=header>
    <!-- <a href="https://browser.exokit.org">
      <img class=icon src="logo.svg"/>
    </a> -->
    <a href="/" class="nav">竹ヨナムマイコ</a>
    <!-- <a href="/" class="nav">Home</a> -->
    <a href="/room.html" class="nav open">Room</a>
    <div class="roomer disconnected">
      <div class="connect-status disconnected">Offline</div>
      <div class=button id=rooms-button>Rooms&nbsp;<i class="fa fa-chevron-down"></i></div>
      <div class=button id=create-room-button>Create room</div>
      <div class=button id=use-code-button>Use code</div>
    </div>
    <div class="roomer list">
      <div class="connect-status disconnected">Choose room...</div>
      <div class=button id=unrooms-button>Rooms&nbsp;<i class="fa fa-chevron-up"></i></div>
      <div class=rooms id=rooms></div>
    </div>
    <div class="roomer dialog">
      <input type=text id=room-code-input placeholder="Enter room code">
      <div class=button id=connect-button>Connect</div>
      <div class=button id=cancel-connect-button>Cancel</div>
    </div>
    <div class="roomer connected">
      <div class=users><i class="fa fa-user"></i> <span id=user-count-text>1</span></div>
      <div class=room-code>Room code: <span class=room-code-text id=room-code-text></span> Link: <a href="#" target="_blank" class=room-link id=room-link><i class="fa fa-external-link"></i></a></div>
      <div class=button id=disconnect-button>Disconnect</div>
    </div>
    <div class=tools>
      <a id=tool-1 class="tool selected" tool="orbit">
        <i class="fal fa-camera"></i>
        <div class=label>Camera tool</div>
      </a>
      <a id=tool-2 class="tool" tool="firstperson">
        <i class="fal fa-eye"></i>
        <div class=label>First person</div>
      </a>
      <a id=tool-3 class="tool" tool="thirdperson">
        <i class="fal fa-walking"></i>
        <div class=label>Third person</div>
      </a>
      <a id=tool-4 class="tool" tool="hud">
        <i class="fal fa-browser"></i>
        <div class=label>Hud</div>
      </a>
      <a id=tool-5 class="tool" tool="trade">
        <i class="fal fa-exchange"></i>
        <div class=label>Trade</div>
      </a>
      <a id=tool-6 class="tool" tool="microphone">
        <i class="fal fa-microphone"></i>
        <div class=label>Microphone</div>
      </a>
      <a id=tool-7 class="tool" tool="screenshare">
        <i class="fal fa-video"></i>
        <div class=label>Screenshare</div>
      </a>
    </div>
    <div class="addressbook">
      <input type=text class=address-input id=address-input placeholder="0x0000000000000000000000000000000000000000" autocomplete=fake>
      <a class=button id=add-address-button>+ Add</a>
      <div class=addresses id=addresses></div>
    </div>
    <div class="wallet none">
      <div class=address>No wallet</div>
      <div class=button id=import-key-button>Import key</div>
      <div class=button id=create-wallet-button>Create wallet</div>
    </div>
    <div class="wallet import">
      <input type=text id=seed-phrase-input placeholder="seed phrase">
      <input type=password id=password-input placeholder="password">
      <div class=button id=import-button>Log in</div>
      <div class=button id=cancel-import-button>Cancel</div>
    </div>
    <div class="wallet locked">
      <div class=address>Wallet locked</div>
      <input type=password id=password-unlock-input placeholder="password">
      <div class=button id=unlock-wallet-button>Unlock</div>
      <div class=button id=forget-wallet-button>Forget</div>
    </div>
    <div class="wallet unlocked">
      <div class=address id=address-text></div>
      <div class=balance id=balance-text></div>
      <div class=button id=download-key-button>D/L key</div>
      <div class=button id=lock-wallet-button>Lock</div>
    </div>
    <div class="xr desktop">
      <!-- <div class=button id=start-capture-button>Start Capture</div> -->
      <div class=button id=enter-vr-button>Enter VR</div>
      <!-- <div class=button id=enter-overlay-button>Enter Overlay</div> -->
    </div>
    <div class="xr vr">VR running</div>
    <div class="xr overlay">Overlay running</div>
  </header>
  <canvas id=canvas></canvas>
<script type=module>
import * as THREE from './three.module.js';
// window.THREE = THREE;
// import {OrbitControls} from './OrbitControls.js';
// import {GLTFLoader} from './GLTFLoader.js';
// import {GLTFExporter} from './GLTFExporter.js';
// import {XRControllerModelFactory} from './XRControllerModelFactory.js';
import {makeId, XRChannelConnection} from 'https://2.metartc.com/xrrtc.js';
// import {initLocalRig, updatePlayerFromCamera, updatePlayerFromXr, updatePlayerFromArrays, updatePlayerDefault, getRigBoneTexture, bindChannelConnection, bindPeerConnection} from './peerconnection.js';
import address from 'https://contracts.webaverse.com/address.js';
import abi from 'https://contracts.webaverse.com/abi.js';

const apiHost = `https://ipfs.exokit.org/ipfs`;
const presenceHost = 'wss://rtc.exokit.org:4443';
const network = 'rinkeby';
const infuraApiKey = '4fb939301ec543a0969f3019d74f80c2';
const rpcUrl = `https://${network}.infura.io/v3/${infuraApiKey}`;
const web3 = new Web3(new Web3.providers.HttpProvider(rpcUrl));
// window.web3 = web3;
const contract = new web3.eth.Contract(abi, address);

const localVector = new THREE.Vector3();
const localMatrix = new THREE.Matrix4();

function parseQuery(queryString) {
  var query = {};
  var pairs = (queryString[0] === '?' ? queryString.substr(1) : queryString).split('&');
  for (var i = 0; i < pairs.length; i++) {
    var pair = pairs[i].split('=');
    query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '');
  }
  return query;
}
function makePromise() {
  let accept, reject;
  const p = new Promise((a, r) => {
    accept = a;
    reject = r;
  });
  p.accept = accept;
  p.reject = reject;
  return p;
}

const canvas = document.getElementById('canvas');
const renderer = new THREE.WebGLRenderer({
  canvas,
  antialias: true,
  preserveDrawingBuffer: true,
});
// renderer.autoClear = false;
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.sortObjects = false;
renderer.physicallyCorrectLights = true;
renderer.xr.enabled = true;
/* renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFShadowMap;
renderer.setClearColor(new THREE.Color(0xEEEEEE), 1);
renderer.viewportEnabled = true;
renderer.setViewport = (oldSetViewport => function setViewport() {
  renderer.viewportEnabled && oldSetViewport.apply(this, arguments);
})(renderer.setViewport); */

const scene = new THREE.Scene();
// scene.background = new THREE.Color(0xEEEEEE);
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0.5, 2);
camera.rotation.order = 'YXZ';

const ambientLight = new THREE.AmbientLight(0xFFFFFF);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 3);
directionalLight.position.set(0.5, 1, 0.5).multiplyScalar(100);
directionalLight.castShadow = true;
directionalLight.shadow.mapSize.width = 1024;
directionalLight.shadow.mapSize.height = 1024;
directionalLight.shadow.camera.near = 0.5;
directionalLight.shadow.camera.far = 500;
scene.add(directionalLight);

const directionalLight2 = new THREE.DirectionalLight(0xFFFFFF, 3);
directionalLight2.position.set(-0.5, 0.1, 0.5).multiplyScalar(100);
scene.add(directionalLight2);

let rig = null;
// let videoMediaStream = null;
let currentSession = null;

const _makeRig = () => {
  const head = new THREE.Mesh(new THREE.BoxBufferGeometry(0.1, 0.05, 0.2), new THREE.MeshPhongMaterial({color: 0xef5350}));
  const leftHand = new THREE.Mesh(new THREE.BoxBufferGeometry(0.05, 0.01, 0.1), new THREE.MeshPhongMaterial({color: 0x66bb6a}));
  const rightHand = new THREE.Mesh(new THREE.BoxBufferGeometry(0.05, 0.01, 0.1), new THREE.MeshPhongMaterial({color: 0x42a5f5}));
  return {
    head,
    leftHand,
    rightHand,
  };
};
const _addRig = rig => {
  scene.add(rig.head);
  scene.add(rig.leftHand);
  scene.add(rig.rightHand);
};
const _removeRig = rig => {
  scene.remove(rig.head);
  scene.remove(rig.leftHand);
  scene.remove(rig.rightHand);
};
const _updateRig = (rig, head, leftHand, rightHand) => {
  rig.head.position.fromArray(head.position);
  rig.head.quaternion.fromArray(head.quaternion);
  rig.leftHand.position.fromArray(leftHand.position);
  rig.leftHand.quaternion.fromArray(leftHand.quaternion);
  rig.rightHand.position.fromArray(rightHand.position);
  rig.rightHand.quaternion.fromArray(rightHand.quaternion);
};
const myRig = _makeRig();
_addRig(myRig);

let channelConnection = null;
let channelConnectionOpen = false;
const peerConnections = [];
let microphoneMediaStream = null;
const _connectMultiplayer = async roomName => {
  channelConnection = new XRChannelConnection(`${presenceHost}/`, {
    roomName,
    // displayName: 'user',
  });
  channelConnection.addEventListener('open', e => {
    channelConnectionOpen = true;

    const queue = [];
    let bufferedAmountLow = true;
    channelConnection.send = (_send => function send(a) {
      // console.log('send', a, this);
      if (bufferedAmountLow) {
        // try {
          bufferedAmountLow = false;
          return _send.apply(this, arguments);
        /* } catch(err) {
          console.log('got error', err);
        } */
      } else {
        queue.push(a);
      }
    })(channelConnection.send);
    channelConnection.dataChannel.addEventListener('bufferedamountlow', e => {
      // console.log('buffered amount low', e);
      bufferedAmountLow = true;
      if (queue.length > 0) {
        /* if (channelConnection.dataChannel.bufferedAmount !== 0) {
          console.log('got buffered amount', channelConnection.dataChannel.bufferedAmount, channelConnection.dataChannel.bufferedAmountLowThreshold);
          throw new Error('already buffered!');
        } */
        channelConnection.send(queue.shift());
      }
    });
  }, {once: true});
  channelConnection.addEventListener('close', e => {
    if (interval) {
      clearInterval(interval);
    }
    channelConnectionOpen = false;
  }, {once: true});
  channelConnection.addEventListener('peerconnection', async e => {
    const peerConnection = e.data;

    let modelUrl = null;
    let playerRig = null;
    let live = true;
    let loading = false;
    const loadQueue = [];
    let sending = false;
    let sendQueue = [];
    let avatarQueued = null;
    const _loadAvatar = async u => {
      if (!loading) {
        loading = true;

        const res = await fetch(u);
        const ab = await res.arrayBuffer();
        const uint8Array = new Uint8Array(ab);
        const p = new XRPackage(uint8Array);
        await xrpackage.add(p);
        if (live) {
          playerRig = p;
        } else {
          xrpackage.remove(p);
        }

        loading = false;

        if (loadQueue.length > 0) {
          const fn = loadQueue.shift();
          fn();
        }
      } else {
        loadQueue.push(() => {
          _loadAvatar(u);
        });
      }
    };

    peerConnections.push(peerConnection);
    peerConnection.addEventListener('close', () => {
      peerConnections.splice(peerConnections.indexOf(peerConnection), 1);
      if (playerRig) {
        xrpackage.remove(playerRig);
        playerRig = null;
      }
      if (interval) {
        clearInterval(interval);
      }
      live = false;
    });
    peerConnection.addEventListener('message', e => {
      const {data} = e;
      if (typeof data === 'string') {
        const j = JSON.parse(data);
        const {method} = j;
        if (method === 'pose') {
          if (playerRig) {
            const {pose} = j;
            playerRig.setPose(pose);
          }
        } else if (method === 'avatar') {
          const {peerId, url} = j;
          console.log('got avatar', peerId, peerConnection.connectionId, url, modelUrl);
          if (peerId === peerConnection.connectionId && url !== modelUrl) {
            modelUrl = url;
            _loadAvatar(url);
          }
        } else {
          console.warn('bad method', j);
        }
      } else {
        // console.log('got non-string data', data, avatarQueued && avatarQueued.url, avatarQueued && avatarQueued.numPackets, avatarQueued && avatarQueued.packets);

        /* if (avatarQueued) {
          avatarQueued.packets.push(data);
          if (avatarQueued.packets.length >= avatarQueued.numPackets) {
            let size = 0;
            for (let i = 0; i < avatarQueued.packets.length; i++) {
              size += avatarQueued.packets[i].byteLength;
            }
            const uint8Array = new Uint8Array(size);
            let index = 0;
            for (let i = 0; i < avatarQueued.packets.length; i++) {
              const packet = avatarQueued.packets[i];
              uint8Array.set(new Uint8Array(packet), index);
              index += packet.byteLength;
            }
            _loadAvatar(uint8Array);
            avatarQueued = null;
          }
        } */
      }
    });

    const res = await fetch('miku.wbn');
    const ab = await res.arrayBuffer();
    const uint8Array = new Uint8Array(ab);
    const p = new XRPackage(uint8Array);
    const hash = await p.upload();
    console.log('got hash', hash);

    let interval;
    if (live) {
      interval = setInterval(() => {
        channelConnection.send(JSON.stringify({
          method: 'avatar',
          peerId: channelConnection.connectionId,
          url: `https://ipfs.exokit.org/ipfs/${hash}.wbn`,
        }));
      }, 1000);
    }
  });
};
const _disconnectMultiplayer = async () => {
  if (channelConnection) {
    channelConnection.disconnect()
    channelConnection = null;
  }
};
window.addEventListener('beforeunload', _disconnectMultiplayer);

/* const planeGeometry = new THREE.SphereGeometry(10, 128, 128);
const planeMaterial = new THREE.MeshBasicMaterial({
  color: 0x0000FF,
  side: THREE.DoubleSide,
});
const plane = new THREE.Mesh(planeGeometry, planeMaterial);
// plane.z = -3;
scene.add(plane); */

_connectMultiplayer('room');

function animate() {
  // orbitControls.update();

  // update local player
  const pose = renderer.xr.getPose();
  if (pose) {
    localMatrix.fromArray(pose.transform.matrix)
      .decompose(myRig.head.position, myRig.head.quaternion, localVector);
    /* myRig.head.position.copy(camera.position);
    myRig.head.quaternion.copy(camera.quaternion); */
    myRig.leftHand.position.copy(myRig.head.position).add(new THREE.Vector3(-0.2, -0.2, -0.3).applyQuaternion(myRig.head.quaternion));
    myRig.leftHand.quaternion.copy(myRig.head.quaternion);
    myRig.rightHand.position.copy(myRig.head.position).add(new THREE.Vector3(0.2, -0.2, -0.3).applyQuaternion(myRig.head.quaternion));
    myRig.rightHand.quaternion.copy(myRig.head.quaternion);
  }

  // send pose to other players
  if (channelConnectionOpen) {
    const pose = [
      [
        myRig.head.position.toArray(),
        myRig.head.quaternion.toArray(),
      ],
      [
        myRig.leftHand.position.toArray(),
        myRig.leftHand.quaternion.toArray(),
      ],
      [
        myRig.rightHand.position.toArray(),
        myRig.rightHand.quaternion.toArray(),
      ],
    ];
    channelConnection.send(JSON.stringify({
      method: 'pose',
      pose,
    }));
  }

  renderer.render(scene, camera);
}
renderer.setAnimationLoop(animate);

navigator.xr.addEventListener('sessiongranted', e => {
  let currentSession = null;
  function onSessionStarted(session) {
    session.addEventListener('end', onSessionEnded);

    renderer.xr.setSession(session);

    currentSession = session;
  }
  function onSessionEnded() {
    currentSession.removeEventListener('end', onSessionEnded);

    currentSession = null;
  }
  navigator.xr && navigator.xr.requestSession('immersive-vr', {
    optionalFeatures: [
      'local-floor',
      'bounded-floor',
    ],
  }).then(onSessionStarted);
});

</script>
</body>
</html>